import { inArray } from "drizzle-orm";
import db from "@/db";
import {
  collections,
  examSessions,
  exams,
  problems,
  sessionProblems,
  testCases,
  user,
} from "@/db/schema";

// Types derived from schema or usage
type ExamConfig =
  | { strategy: "fixed"; problemIds: string[] }
  | { strategy: "random_pool"; collectionId: string; count: number };

const SAMPLE_CONTENT = {
  type: "doc",
  content: [
    {
      type: "paragraph",
      content: [
        {
          type: "text",
          text: "This is a sample problem description generated by the seed script. Write a function that solves the problem efficiently.",
        },
      ],
    },
  ],
};

const SAMPLE_METADATA = {
  timeLimit: 1000,
  memoryLimit: 256,
};

async function seedData() {
  console.log("üå± Starting seed...");

  try {
    // 1. Fetch a creator user (Admin or Instructor)
    // We try to find 'admin' or 'instructor' seeded by users.ts
    const creator = await db.query.user.findFirst({
      where: inArray(user.role, ["admin", "instructor"]),
    });

    if (!creator) {
      console.error(
        "‚ùå No admin or instructor found. Please run 'npm run seed:users' first.",
      );
      process.exit(1);
    }
    console.log(`üë§ Using creator: ${creator.username} (${creator.id})`);

    // 2. Clean existing data
    // Order matters for FK constraints:
    // sessionProblems -> examSessions -> (exams)
    // testCases -> problems -> (collections)
    console.log("üßπ Cleaning existing data...");
    await db.delete(sessionProblems);
    await db.delete(examSessions);
    await db.delete(exams);
    await db.delete(testCases);
    await db.delete(problems);
    await db.delete(collections);
    console.log("‚úÖ Data cleaned.");

    // 3. Create Collections
    console.log("üìö Creating collections...");
    const collectionData = [
      {
        name: "CS 101: Intro to Programming",
        description: "Basic programming concepts and logic puzzles.",
      },
      {
        name: "Data Structures",
        description: "Arrays, Linked Lists, Trees, and Graphs.",
      },
      {
        name: "Algorithms",
        description: "Sorting, Searching, and Dynamic Programming.",
      },
    ];

    const insertedCollections = [];
    for (const c of collectionData) {
      const [inserted] = await db
        .insert(collections)
        .values({
          name: c.name,
          description: c.description,
          public: true,
          createdBy: creator.id,
        })
        .returning();
      insertedCollections.push(inserted);
    }
    console.log(`‚úÖ Created ${insertedCollections.length} collections.`);

    // 4. Create Problems & TestCases
    console.log("üß© Creating problems and testcases...");
    const allProblemIds: string[] = [];
    const problemsPerCollection = 5; // 3 collections * 5 = 15 problems total

    for (const col of insertedCollections) {
      for (let i = 1; i <= problemsPerCollection; i++) {
        // Create Problem
        const [prob] = await db
          .insert(problems)
          .values({
            collectionId: col.id,
            type: "coding",
            difficulty: i % 3 === 0 ? "hard" : i % 2 === 0 ? "medium" : "easy",
            title: `${col.name} - Problem ${i}`,
            description: `Solve problem ${i} in ${col.name}`,
            content: SAMPLE_CONTENT,
            gradingMetadata: SAMPLE_METADATA,
            public: true,
            createdBy: creator.id,
          })
          .returning();

        allProblemIds.push(prob.id);

        // Create TestCases
        // 3 visible, 7 hidden
        const testCaseData = [];
        for (let t = 1; t <= 10; t++) {
          testCaseData.push({
            problemId: prob.id,
            input: `input_${t}`,
            expectedOutput: `output_${t}`,
            isHidden: t > 3, // First 3 visible (false), rest hidden (true)
          });
        }
        await db.insert(testCases).values(testCaseData);
      }
    }
    console.log(
      `‚úÖ Created ${allProblemIds.length} problems with 10 testcases each.`,
    );

    // 5. Create Exams
    console.log("üìù Creating exams...");
    const now = new Date();
    const oneDay = 24 * 60 * 60 * 1000;

    const examScenarios = [
      // 2 Upcoming
      {
        title: "Midterm Exam (Upcoming 1)",
        startOffset: oneDay, // starts tomorrow
        endOffset: oneDay * 2,
        duration: 60,
        config: {
          strategy: "random_pool",
          collectionId: insertedCollections[0].id,
          count: 5,
        },
      },
      {
        title: "Final Exam (Upcoming 2)",
        startOffset: oneDay * 5,
        endOffset: oneDay * 6,
        duration: 120,
        config: { strategy: "fixed", problemIds: allProblemIds.slice(0, 5) },
      },
      // 2 Completed
      {
        title: "Quiz 1 (Completed 1)",
        startOffset: -oneDay * 5,
        endOffset: -oneDay * 4,
        duration: 30,
        config: {
          strategy: "random_pool",
          collectionId: insertedCollections[1].id,
          count: 3,
        },
      },
      {
        title: "Quiz 2 (Completed 2)",
        startOffset: -oneDay * 2,
        endOffset: -oneDay * 1,
        duration: 45,
        config: { strategy: "fixed", problemIds: allProblemIds.slice(5, 10) },
      },
      // 3 Ongoing
      {
        title: "Weekly Contest (Ongoing 1)",
        startOffset: -oneDay, // started yesterday
        endOffset: oneDay, // ends tomorrow
        duration: 180,
        config: {
          strategy: "random_pool",
          collectionId: insertedCollections[2].id,
          count: 5,
        },
      },
      {
        title: "Pop Quiz (Ongoing 2)",
        startOffset: -1000 * 60 * 30, // started 30 mins ago
        endOffset: 1000 * 60 * 60, // ends in 1 hour
        duration: 45,
        config: { strategy: "fixed", problemIds: allProblemIds.slice(10, 15) },
      },
      {
        title: "Entrance Exam (Ongoing 3)",
        startOffset: -1000 * 60 * 60 * 2, // started 2 hours ago
        endOffset: 1000 * 60 * 60 * 24, // ends tomorrow
        duration: 90,
        config: {
          strategy: "random_pool",
          collectionId: insertedCollections[0].id,
          count: 10,
        },
      },
    ];

    for (const s of examScenarios) {
      await db.insert(exams).values({
        title: s.title,
        startTime: new Date(now.getTime() + s.startOffset),
        endTime: new Date(now.getTime() + s.endOffset),
        durationMinutes: s.duration,
        config: s.config,
        createdBy: creator.id,
      });
    }
    console.log(`‚úÖ Created ${examScenarios.length} exams.`);

    console.log("üéâ Seeding completed successfully!");
    process.exit(0);
  } catch (error) {
    console.error("‚ùå Error seeding data:", error);
    process.exit(1);
  }
}

seedData();
